<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="https://glitch.com/favicon.ico" />
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-environment-component@1.3.3/dist/aframe-environment-component.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.1.0/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/gearcoded/aframe-physics-system@master/dist/aframe-physics-system.min.js"></script>
  <style>
    .a-dialog-text {
      color: white;
      font-size: 24px;
    }
  </style>
</head>

<body>
  <a-scene vr-mode-ui="enabled: true" physics="debug: false; gravity: 0 -9.8 0;">
    <a-assets>
      <a-asset-item id="ginga1" src="assets/Ginga1.glb"></a-asset-item>
      <a-asset-item id="macaco" src="assets/Macaco%20Side.glb"></a-asset-item>
      <a-asset-item id="troca" src="assets/Troca.glb"></a-asset-item>
      <a-asset-item id="martelo3" src="assets/Martelo3.glb"></a-asset-item>
      <a-asset-item id="ginga&compasso" src="assets/ginga%26compasso.glb"></a-asset-item>
      <audio id="audio" src="assets/Luna.ogg"></audio>
    </a-assets>

    <a-entity id="cameraRig" position="0 0 0">
      <a-entity id="camera" camera look-controls wasd-controls="enabled:true;">
        <!-- Collision feedback text - attached to camera so it's always visible -->
        <a-entity id="collisionText" position="0 0 -2" 
                  text="value: Waiting for collisions...; align: center; width: 2; color: cyan; font: mozillavr"
                  visible="true"></a-entity>

        <a-entity id="timerText" position="0 1.4 -2" text="value: ; 
                  align: center;
                  width: 2;
                  color: red;
                  font: mozillavr" visible="false"></a-entity>

        <a-entity id="moveTitleText" position="0 1.2 -2" text="value: Current Move: Ginga; 
                  align: center;
                  width: 2;
                  color: yellow;
                  font: mozillavr" visible="false"></a-entity>

        <a-entity id="instructionText" position="0 0.7 -2" text="value: Welcome to Capoeira Training!\nPress the joystick at any time for help.; 
                  align: center;
                  width: 2;
                  color: white;
                  font: mozillavr" visible="false"></a-entity>

        <a-entity id="helpScreen" position="0 0.3 -2" rotation="0 0 0" visible="false">
          <a-entity position="0 0 0" text="value: CONTROLS (try them while reading)\n\n
                    A button (Left): Next offensive move\n
                    B button (Left): Next defensive move\n
                    X button (Left): Toggle Roda Mode on/off\n
                    Grip: Slow motion :D\n
                    Trigger: Rotate model\n
                    Joystick Press: Show/hide this guide\n\n
                    GAME GUIDE\n
                    - Switch between offensive and defensive moves\n
                    - Use Roda mode for automatic move changes\n
                    - Use slow motion & rotation to study techniques\n
                    - Make sure your surroundings are safe\n
                    - To learn more about Capoeira visit lalaue.com\n
                    - To center the screen, hold the Oculus button\n
                    - To exit, shortly press the Oculus button;
                    align: center;
                    width: 1.5;
                    color: white;
                    font: mozillavr;
                    wrapCount: 35"></a-entity>
        </a-entity>

        <a-entity id="welcomeScreen" position="0 0.5 -2" rotation="0 0 0" visible="true">
          <a-entity position="0 0.5 0" text="value: Welcome to the Capoeira VR Trainer!\n\n
                    Learn fundamental movements and kicks used in Capoeira.\n\n
                    Focus on the model and practice along with the animation.\n\n
                    Press the **B button** on your **right controller** to begin!;
                    align: center;
                    width: 2.5;
                    color: yellow;
                    font: mozillavr;
                    wrapCount: 50"></a-entity>
        </a-entity>
      </a-entity>
    </a-entity>

    <a-entity id="modelContainer">
      <a-gltf-model id="model" src="#ginga1" scale="0.01 0.01 0.01" position="0 0 -2" rotation="0 0 0"
        animation-mixer="timeScale: 1">
      </a-gltf-model>
    </a-entity>

    <!-- Floor for physics -->
    <a-plane static-body position="0 0 0" rotation="-90 0 0" width="20" height="20" color="#7BC8A4" opacity="0.3"></a-plane>

    <!-- Test Object to check collisions -->
    <a-sphere id="testBall" position="0.5 1.5 -1.5" radius="0.1" color="orange" 
              dynamic-body="mass: 1; linearDamping: 0.1; angularDamping: 0.1"
              collision-detector></a-sphere>

    <a-entity id="leftHand" oculus-touch-controls="hand: left"></a-entity>
    <a-entity id="rightHand" oculus-touch-controls="hand: right"></a-entity>

    <a-entity sound="src: #audio; autoplay: true; loop: true; volume: 0.5" environment="preset: forest"></a-entity>
  </a-scene>

  <script>
    // --- CONSTANTS ---
    const DEFAULT_RODA_TIME = 10;
    const SLOW_MOTION_SCALE = 0.4;
    const NORMAL_TIME_SCALE = 1;
    const DEFENSIVE_START_INDEX = 0;
    const OFFENSIVE_START_INDEX = 0;
    const DEFAULT_MODEL_ROTATION = 0;
    const FACING_AWAY_ROTATION = 180;

    const moveData = {
      defensive: [
        { id: "#ginga1", title: "Ginga" },
        { id: "#macaco", title: "Macaco (Monkey Move)" },
        { id: "#troca", title: "Troca (Exchange)" },
      ],
      offensive: [
        { id: "#martelo3", title: "Martelo (Hammer Kick)" },
        { id: "#ginga&compasso", title: "Compasso (Compass Kick)" },
      ],
    };

    // --- STATE ---
    let state = {
      isGameStarted: false,
      currentDefensiveIndex: DEFENSIVE_START_INDEX,
      currentOffensiveIndex: OFFENSIVE_START_INDEX,
      isRodaModeActive: false,
      rodaInterval: null,
      timeLeft: DEFAULT_RODA_TIME,
      isFacingAway: false,
      isHelpVisible: false,
      currentMoveType: 'defensive',
      colliders: [] // Track dynamic colliders
    };

    // --- DOM ELEMENTS ---
    const entity = document.getElementById("model");
    const instructionText = document.getElementById("instructionText");
    const helpScreen = document.getElementById("helpScreen");
    const moveTitleText = document.getElementById("moveTitleText");
    const timerText = document.getElementById("timerText");
    const leftHand = document.getElementById("leftHand");
    const rightHand = document.getElementById("rightHand");
    const welcomeScreen = document.getElementById("welcomeScreen");

    // --- A-FRAME COMPONENTS ---

    // Custom component for Y-axis rotation following
    AFRAME.registerComponent("follow-camera-y", {
      tick: function () {
        const cameraRigRotation = document
          .getElementById("cameraRig")
          .getAttribute("rotation");
        this.el.setAttribute("rotation", { x: 0, y: cameraRigRotation.y, z: 0 });
      },
    });

    // Add the follow-camera-y component to the model container
    document.getElementById("modelContainer").setAttribute("follow-camera-y", "");

    // Collision detector component
    AFRAME.registerComponent("collision-detector", {
      init: function () {
        this.collisionCount = 0;
        this.el.addEventListener('collide', (e) => {
          this.collisionCount++;
          const otherEl = e.detail.body.el;
          const otherName = otherEl.id || otherEl.className || 'unknown object';
          
          // Update collision text in center of screen
          const collisionText = document.getElementById('collisionText');
          if (collisionText) {
            collisionText.setAttribute('text', 'value', 
              `COLLISION #${this.collisionCount}\nBall hit: ${otherName}\n\nTotal collisions: ${this.collisionCount}`);
            collisionText.setAttribute('text', 'color', 'lime');
            
            // Fade back to cyan after 2 seconds
            setTimeout(() => {
              collisionText.setAttribute('text', 'color', 'cyan');
            }, 2000);
          }
          
          // Flash the ball
          this.el.setAttribute('color', 'red');
          setTimeout(() => {
            this.el.setAttribute('color', 'orange');
          }, 200);
        });
      }
    });

    // Custom component to create dynamic physics colliders for bones
    AFRAME.registerComponent("bone-collider-system", {
      schema: {
        bones: { type: 'array', default: ['mixamorigLeftFoot', 'mixamorigRightFoot', 'mixamorigLeftHand', 'mixamorigRightHand'] },
        radius: { type: 'number', default: 0.15 }
      },
      init: function () {
        this.colliders = [];
        this.bones = [];
        
        this.el.addEventListener('model-loaded', () => {
          const mesh = this.el.getObject3D('mesh');
          if (mesh) {
            // Find all specified bones
            this.data.bones.forEach(boneName => {
              mesh.traverse((node) => {
                if (node.isBone && node.name === boneName) {
                  this.bones.push(node);
                  
                  // Create a sphere entity for collision
                  const colliderEl = document.createElement('a-sphere');
                  colliderEl.setAttribute('radius', this.data.radius);
                  colliderEl.setAttribute('color', 'red');
                  colliderEl.setAttribute('opacity', 0.5);
                  colliderEl.setAttribute('visible', true); // Visible for debugging
                  colliderEl.setAttribute('class', `collider-${boneName}`);
                  colliderEl.setAttribute('dynamic-body', {
                    mass: 0.5,
                    linearDamping: 0.95,
                    angularDamping: 0.95
                  });
                  
                  // Add collision listener to collider
                  colliderEl.addEventListener('collide', (e) => {
                    const otherEl = e.detail.body.el;
                    if (otherEl.id === 'testBall') {
                      const collisionText = document.getElementById('collisionText');
                      if (collisionText) {
                        collisionText.setAttribute('text', 'value', 
                          `KICK DETECTED!\n${boneName} hit the ball!\n\nGreat technique!`);
                        collisionText.setAttribute('text', 'color', 'yellow');
                        
                        // Fade back to cyan after 2 seconds
                        setTimeout(() => {
                          collisionText.setAttribute('text', 'color', 'cyan');
                          collisionText.setAttribute('text', 'value', 'Waiting for collisions...');
                        }, 3000);
                      }
                      
                      // Visual feedback on collider
                      colliderEl.setAttribute('color', 'yellow');
                      setTimeout(() => {
                        colliderEl.setAttribute('color', 'red');
                      }, 200);
                    }
                  });
                  
                  this.el.sceneEl.appendChild(colliderEl);
                  this.colliders.push({ element: colliderEl, bone: node, name: boneName });
                }
              });
            });
            
            console.log(`Created ${this.colliders.length} bone colliders`);
            
            // Update collision text to show system is ready
            const collisionText = document.getElementById('collisionText');
            if (collisionText) {
              collisionText.setAttribute('text', 'value', 
                `Physics Ready!\n${this.colliders.length} bone colliders active\n\nTry to kick the orange ball!`);
            }
          }
        });
      },
      tick: function () {
        // Update collider positions to match bone positions
        this.colliders.forEach(({ element, bone }) => {
          const worldPos = new THREE.Vector3();
          bone.getWorldPosition(worldPos);
          element.setAttribute('position', worldPos);
          
          // Force physics body update
          if (element.body) {
            element.body.position.copy(worldPos);
            element.body.velocity.set(0, 0, 0);
            element.body.angularVelocity.set(0, 0, 0);
          }
        });
      },
      remove: function () {
        // Clean up colliders when component is removed
        this.colliders.forEach(({ element }) => {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        });
        this.colliders = [];
      }
    });

    // --- GAME FLOW FUNCTIONS ---

    function startGame() {
      if (state.isGameStarted) return;

      state.isGameStarted = true;
      welcomeScreen.setAttribute('visible', false);
      instructionText.setAttribute('visible', true);
      moveTitleText.setAttribute('visible', true);
      updateModel(state.currentMoveType);
      instructionText.setAttribute(
        "text",
        "value",
        "Welcome to Capoeira Training!\nPress the joystick at any time for help."
      );
    }

    function toggleHelpScreen() {
      if (!state.isGameStarted) return;
      state.isHelpVisible = !state.isHelpVisible;
      helpScreen.setAttribute("visible", state.isHelpVisible);
    }

    // --- MODEL UPDATE FUNCTIONS ---

    function getRandomMove(moveType) {
      const moves = moveData[moveType];
      const randomIndex = Math.floor(Math.random() * moves.length);
      return moves[randomIndex];
    }

    function getNextSequentialMove(moveType) {
      const moves = moveData[moveType];
      let currentIndex;

      if (moveType === 'offensive') {
        currentIndex = state.currentOffensiveIndex;
        state.currentOffensiveIndex = (currentIndex + 1) % moves.length;
      } else {
        currentIndex = state.currentDefensiveIndex;
        state.currentDefensiveIndex = (currentIndex + 1) % moves.length;
      }
      return moves[currentIndex];
    }

    function updateModel(moveType, isRodaMode = false) {
      state.currentMoveType = moveType;
      let move;

      if (isRodaMode) {
        move = getRandomMove(moveType);
      } else {
        move = getNextSequentialMove(moveType);
      }

      // Remove old collider system if exists
      if (entity.components['bone-collider-system']) {
        entity.removeAttribute('bone-collider-system');
      }

      entity.setAttribute("src", move.id);
      
      // Re-add collider system after model loads
      entity.addEventListener('model-loaded', function addColliders() {
        entity.setAttribute('bone-collider-system', '');
        entity.removeEventListener('model-loaded', addColliders);
      }, { once: true });

      moveTitleText.setAttribute(
        "text",
        "value",
        `Current Move: ${move.title}`
      );

      instructionText.setAttribute(
        "text",
        "value",
        moveType === "offensive"
          ? "Practice your defense. Don't get hit!"
          : "Practice your offense. Attack!"
      );

      const yRotation = state.isFacingAway ? FACING_AWAY_ROTATION : DEFAULT_MODEL_ROTATION;
      entity.setAttribute("rotation", `0 ${yRotation} 0`);
    }

    // Set initial model for display on the welcome screen
    updateModel(state.currentMoveType);

    // --- RODA MODE FUNCTIONS ---

    function updateTimer() {
      timerText.setAttribute("text", "value", `Next move in: ${state.timeLeft}s`);
    }

    function startRodaSequence() {
      let isOffensive = Math.random() < 0.5;
      state.timeLeft = DEFAULT_RODA_TIME;
      updateTimer();
      updateModel(isOffensive ? "offensive" : "defensive", true);

      state.rodaInterval = setInterval(() => {
        state.timeLeft--;
        updateTimer();

        if (state.timeLeft <= 0) {
          isOffensive = !isOffensive;
          state.timeLeft = DEFAULT_RODA_TIME;
          updateModel(isOffensive ? "offensive" : "defensive", true);
        }
      }, 1000);
    }

    function stopRodaSequence() {
      clearInterval(state.rodaInterval);
      state.rodaInterval = null;
      timerText.setAttribute("text", "value", "");
      state.currentDefensiveIndex = DEFENSIVE_START_INDEX;
      state.currentOffensiveIndex = OFFENSIVE_START_INDEX;
      updateModel("defensive", false);
    }

    function toggleRodaMode() {
      if (!state.isGameStarted) return;

      state.isRodaModeActive = !state.isRodaModeActive;
      timerText.setAttribute("visible", state.isRodaModeActive);

      if (state.isRodaModeActive) {
        instructionText.setAttribute(
          "text",
          "value",
          "Roda Mode Active - Follow the sequence!"
        );
        startRodaSequence();
      } else {
        instructionText.setAttribute(
          "text",
          "value",
          "Roda Mode Deactivated - Manual control restored"
        );
        stopRodaSequence();
      }
    }

    // --- INPUT HANDLERS ---

    function handleGripDown() {
      if (!state.isGameStarted) return;
      entity.setAttribute("animation-mixer", "timeScale", SLOW_MOTION_SCALE);
    }

    function handleGripUp() {
      if (!state.isGameStarted) return;
      entity.setAttribute("animation-mixer", "timeScale", NORMAL_TIME_SCALE);
    }

    function handleTriggerDown() {
      if (!state.isGameStarted) return;
      state.isFacingAway = !state.isFacingAway;
      const yRotation = state.isFacingAway ? FACING_AWAY_ROTATION : DEFAULT_MODEL_ROTATION;
      entity.setAttribute("rotation", `0 ${yRotation} 0`);
    }

    // --- EVENT LISTENERS ---

    function attachControllerEvents(controller) {
      controller.addEventListener("gripdown", handleGripDown);
      controller.addEventListener("gripup", handleGripUp);
      controller.addEventListener("triggerdown", handleTriggerDown);
      controller.addEventListener("thumbstickdown", toggleHelpScreen);

      if (controller.id === "leftHand") {
        controller.addEventListener(
          "abuttondown",
          () => state.isGameStarted && !state.isRodaModeActive && updateModel("offensive")
        );
        controller.addEventListener(
          "bbuttondown",
          () => state.isGameStarted && !state.isRodaModeActive && updateModel("defensive")
        );
        controller.addEventListener("xbuttondown", toggleRodaMode);
      } else if (controller.id === "rightHand") {
        controller.addEventListener("abuttondown", toggleRodaMode);
        controller.addEventListener("bbuttondown", startGame);
      }
    }

    attachControllerEvents(leftHand);
    attachControllerEvents(rightHand);

  </script>
</body>

</html>